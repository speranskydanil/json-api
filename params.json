{"name":"JSON API","tagline":"json-api is a simple library similar to rest-client and httparty, which helps with wrappers around APIs.","body":"# JSON API\r\n\r\njson-api is a simple library similar to rest-client and httparty, which helps with wrappers around APIs.\r\n\r\n## Installing\r\n\r\n```\r\ngem install json_api\r\n\r\nrequire 'json-api'\r\n```\r\n\r\n## Quick requests\r\n\r\nIf you want to do only a couple of requests, then you could call methods directly on JsonApi.<br>\r\n`get`, `post`, `delete` and `put` methods are available. Parameters are passed as a hash.<br>\r\n`code`, `body`, `json`, `hash`, `message` are the most noticeable attributes of responses.\r\n\r\n\r\n```ruby\r\nres = JsonApi.get 'https://api.github.com/search/repositories', q: 'created:>2015-04-01 stars:>100'\r\n\r\nputs res.code #=> '200'\r\nputs res.body #=> \"{\\\"total_count\\\":82,\\\"incomplete_results\\\":false,\\\"items\\\":[{\\\"id\\\":33538019...\"\r\nputs res.json #=> pretty json\r\nputs res.hash #=> ruby hash object from parsed json\r\n```\r\n\r\n## Writing a wrapper\r\n\r\nWhen you work with an API probably you would like to specify `base_path` for all requests.<br>\r\nAlso you may want to specify some `default_params`.<br>\r\nNow lets create a wrapper with a parametrized method.\r\n\r\n```ruby\r\nclass GitHubApi\r\n  include JsonApi\r\n\r\n  def initialize\r\n    @base_path      = 'https://api.github.com'\r\n    @default_params = { per_page: 12 }\r\n  end\r\n\r\n  def search(created, stars)\r\n    res = get 'search/repositories', q: \"created:>#{created} stars:>#{stars}\"\r\n\r\n    raise res.hash['message'] unless res.ok?\r\n    res.hash['items']\r\n  end\r\nend\r\n\r\nrepos = GitHubApi.search('2015-04-01', 100) #=> array with 12 repositories\r\n```\r\n\r\nWe've included JsonApi module.<br>\r\nAs you can see we can specify `@base_path` and `@default_params` in initialization.<br>\r\nIt will work for all requests.<br>\r\nMethods like `get` method are available now in the class,<br>\r\nand we've used `get` in `search` method body.<br>\r\nSee \"Quick requests\" for details about http methods and response methods.\r\n\r\n## Parametrized initialization\r\n\r\nNote we've used `GitHubApi.search` instead of `GitHubApi.new.search` variant.<br>\r\nLibrary allows you to do that.<br>\r\nBut usually you need to configure an instance of wrapper.<br>\r\n\r\n```ruby\r\nclass GitHubApi\r\n  include JsonApi\r\n\r\n  def initialize(per_page)\r\n    @base_path      = 'https://api.github.com'\r\n    @default_params = { per_page: per_page }\r\n  end\r\n\r\n  # ...\r\nend\r\n\r\ngithub_api = GitHubApi.new(12)\r\n\r\nrepos = github_api.search('2015-04-01', 100) #=> array with 12 repositories\r\n```\r\n\r\n## Error handling\r\n\r\nUsually an API have a consistent way of returning errors.<br>\r\nAnd usually you want to handle them consistently.<br>\r\n\r\nSuppose we need to handle errors as following:\r\n\r\n```ruby\r\nraise 'GitHubApi: Error message: ' + res.hash['message'] unless res.ok?\r\n```\r\n\r\nIt would be too bad to write such code everywhere.<br>\r\nSo write just `raise res.error unless res.ok?`, and add next method:\r\n\r\n```ruby\r\ndef error(res)\r\n  'GitHubApi: Error message: ' + res.hash['message']\r\nend\r\n```\r\n\r\n`error` method will be generated automatically for responses.<br>\r\n`ok?` method which was used already several times returns true if code is \"200\".\r\n\r\n## Logging\r\n\r\nYou may specify logger for debugging. It should be a Proc object.<br>\r\nFor example `proc { |s| puts s }` or just `method(:puts)`.<br>\r\n\r\n```ruby\r\nclass GitHubApi\r\n  include JsonApi\r\n\r\n  def initialize\r\n    @base_path      = 'https://api.github.com'\r\n    @default_params = { per_page: 12 }\r\n    @logger         = method(:puts)\r\n  end\r\n\r\n  # ...\r\nend\r\n\r\nrepos = GitHubApi.search('2015-04-01', 100)\r\n```\r\n\r\nExample with using ActiveSupport:\r\n\r\n```ruby\r\n# standalone application\r\n@logger = ActiveSupport::Logger.new(STDOUT).method(:info)\r\n# in rails\r\n@logger = logger.method(:info)\r\n```\r\n\r\nIt will produce output:\r\n\r\n```\r\n[JsonApi#request begin]\r\n# Request\r\nMethod - get\r\nPath   - https://api.github.com/search/repositories\r\nParams -\r\n{:per_page=>12, :q=>\"created:>2015-04-01 stars:>100\"}\r\n# Response\r\nCode - 200\r\nBody -\r\n{\r\n  \"total_count\": 82,\r\n  \"incomplete_results\": false,\r\n  \"items\": [\r\n    {\r\n      \"id\": 33538019,\r\n      ...\r\n[JsonApi#request end]\r\n```\r\n\r\n## Configuring requests\r\n\r\nIf you want to provide headers, or prepare request in other way,<br>\r\nYou may override method called `configure_request`.\r\n\r\n```ruby\r\ndef configure_request(req)\r\n  req['Authorization'] = session[:token]\r\nend\r\n```\r\n\r\n## Routing\r\n\r\nIt's nice to have all routes in one single place.<br>\r\nThe library provides `routes` class method, which accepts a hash.<br>\r\nFor every named route `#{name}_path` method will be generated automatically.<br>\r\nTake a look at the code.\r\n\r\n```ruby\r\nclass GitHubApi\r\n  include JsonApi\r\n\r\n  def initialize\r\n    @base_path      = 'https://api.github.com'\r\n    @default_params = { per_page: 12 }\r\n  end\r\n\r\n  routes search: 'search/repositories',\r\n           user: -> name { \"users/#{name}\" }\r\n\r\n  def search(created, stars)\r\n    res = get search_path, q: \"created:>#{created} stars:>#{stars}\"\r\n\r\n    raise res.error unless res.ok?\r\n    res.hash['items']\r\n  end\r\n\r\n  def user(name)\r\n    res = get user_path(name)\r\n\r\n    raise res.error unless res.ok?\r\n    res.hash\r\n  end\r\n\r\n  def error(res)\r\n    res.hash['message']\r\n  end\r\nend\r\n\r\nrepos = GitHubApi.search('2015-04-01', 100)\r\nuser = GitHubApi.user('dhh')\r\n```\r\n\r\n**Author (Speransky Danil):**\r\n[Personal Page](http://dsperansky.info) |\r\n[LinkedIn](http://ru.linkedin.com/in/speranskydanil/en) |\r\n[GitHub](https://github.com/speranskydanil?tab=repositories) |\r\n[StackOverflow](http://stackoverflow.com/users/1550807/speransky-danil)\r\n\r\n","google":"UA-48799405-1","note":"Don't delete this file! It's used internally to help with page regeneration."}